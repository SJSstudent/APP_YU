문제 해석하는 방법
그냥 간단하게 생각한다면 666->1666->....5666->6666 으로 생각 할 수 있다
하지만 문제에서 보면 차례데로 한다고 적혀있다. 
이 말은 즉, 666가 연속으로 나오는 숫자를 차례데로 출력하라는 뜻이다
따라서 5666->6666 전에 666이 나오는 숫자는 6660이 있으므로 5666->6660->6666 이다

좌표 압축
index() 함수는 시간 복잡도가 O(n)이다.
따라서 index함수를 사용하지 않고 문제를 풀어야한다.

수 정렬하기 3
문제의 key포인트는 메모리 최적화이다.
메모리 최적화를 할려면 파이썬 기준으로 함수를 적게 사용하면 메모리가 적다
따라서 함수를 사용하지 않고 정렬하는 문제였던 것

회사에 있는 사람
한 사람이 회사에 2번 이상으로 출근을 할 수 있기에 set을 사용하기 보다
dic와 0,1을 이용하여 문제를 풀어야한다.
remove와 같은 리스트로 하지 않는 이유는 시간복잡도가 O(N)이기 때문에
시간초과가 뜨기 때문이다.

서로 다른 부분 문자열의 개수
문제를 해석을 했지만 시간복잡도가 O(N**2)이라 시간 초과가 나올 것이라 예상했으나 범위가 1000까지라 시간 초과가 나올 수가 없다.
시간복잡도가 비효율적이라 해도 범위에 따라 가능할 수도 있다.
입력이 abcdf 일 때a,b,c,d,f,ab,bc 순으로 차례데로 만들 수 있지만
a,ab,abc,abcd,abcdf,b,... 순으로도 가능하다
코드를 만들 때 후자 방법으로 하는 것이 효율적이다.

최소공배수
문제는 너무나 쉽다. 하지만 수학적 사고가 돌아가지 않는다면 조금 어려운 문제이다.
최소공배수는 무조건 존재하기에 range(max([a,b]),a*b+1)을 for돌리고
문제를 풀면 된다.

유클리드 호제법
최대공약수 문제에서 많이 볼 수 있는 공식이다. 방정식, 정수론 알고리즘 등 많은 곳에서 사용된다.  따라서 유클리드 호제법을 아는 것과 모른는 것은 하늘과 땅차이기에 한번 적어 본다.
R=A%B
A,B 최대공약수는 B와 R의 최대공약수와 같다.
증명
A=aG,B=bG (a,b)
A=Q*bg+R
aG=Q*bg+R
R=(a-Q*b)G
(a-Q*b)=C
C와 b는 서로소이다.

C와 b는 서로소가 아니다라고 가정을 해서 증명을 한다면
C=np b=mp
(a-Q*b)=np
a-Q*mp=np
a=(Q*m+n)p
b=mp
a와 b가 서로소가 아니다 하지만 우리는 위에 a와b가 서로소라는 걸 알고있다.
따라서 위 공식은 위배된다. 위 공식은 위배 되기 때문에 자연스럽게 C와 b는 서로서이다
C와b를 서로소라고 찾는 이유는 
R=CG B=bG C와 b가 서로소라면 C와 b의 최대공약수는 G가 된다 즉 A와 B의 최대공약수와
R와 B의 최대공약수가 같다.

백준 pypy3와 python의 차이
python은 그냥 우리가 알고있는 파이썬 인터프리터로 실행하는 결과이다.
하지만 pypy는 파이썬으로 파이썬을 만드는 것으로 이유는 모르겠지만 연산 속도가 더 빠름

체스판 다시 칠하기
한달 동안 생각한 문제이다. 솔직히 말하면 그정도는 아니다 고등학교 연구생 시절의 안좋은 습관이 남아있어서 오래 걸린 듯.. 시발 ㅈ같은 문제이다.
옳바른 체스판 2개와 입력받은 체스판을 비교하면서 풀어가는 문제이다.
나는 이런 비교하면서 문제를 푸는 것이 별로이고 좋지 못한다고 생각했다.
그 이유는 코드가 더러워지고 귀찮기 때문이다. 하지만 다시 생각해보면 이 방법 말고는 푸는 방법이 없다...

카드2
나는 파이썬에서 슬라이싱의 시간 복잡도가 O(1)인 줄 알았으나 알고보니 O(N)이였다
따리서 데크를 이용하여 문제릃 풀면 성공 할 수 있다.